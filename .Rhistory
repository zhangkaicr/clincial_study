##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
##以下保存本次处理数据
##newdata为按照阈值删除列后内容
##completa_data为没有缺失的数据集
save(newdata,"newdata.Rdata")
save(newdata,file = "newdata.RData")
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下进行亚组分析
data_final%>%filter(.,TBIL>=250)->data_final
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:17];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
write.csv(t2,"Univariate_analysis.csv")
t2
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:17];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
write.csv(t2,"Univariate_analysis.csv")
#以下进行亚组分析
data_final%>%filter(.,TBIL>=250)->data_final
##载入需要的R包
library(compareGroups)
library(rms)
library(ggpubr)
library(finalfit)
library(gtsummary)
library(tidyverse)
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下进行亚组分析
data_final%>%filter(.,TBIL>=250)->data_final
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:17];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
keep_models=T) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F,
keep_models=T) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
View(data_final)
allvar <- allvar[1:15];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
allvar <- allvar[16];allvar
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[16];allvar
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[17];allvar
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[15];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
write.csv(t2,"Univariate_analysis.csv")
allvar <- allvar[14];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
t2
allvar <- allvar[14];allvar
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[14];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
t2
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:14];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
library(compareGroups)
library(rms)
library(ggpubr)
library(finalfit)
library(gtsummary)
library(tidyverse)
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下进行亚组分析
data_final%>%filter(.,TBIL>=250)->data_final
View(data_final)
#以下进行结果变量定义
dependent <-"Complication.Criteria"
dependent
#以下进行单因素分析
explanatory <- allvar
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:17];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
suppressMessages ... tryCatchList -> confint -> confint.glm -> profile -> profile.glm
suppressMessages
profile.glm
##载入需要的R包
rm(list = ls())
options(stringsAsFactors = T)
library(tidyverse)
library(naniar)
library(UpSetR)
rawdata <- read.csv("4.csv",header = T,
row.names = 1,na.strings = "na")
str(rawdata)#注意变量类型
##以下将需部分变量变为分类变量
vars <- c("ASA ")
rawdata<- rawdata %>%
mutate(across(one_of(vars), as.factor))
str(rawdata)
##更改变量因子水平
rawdata$PBD <- relevel(rawdata$PBD,ref = "none")
##查看没有缺失值的行的总体数据集
completa_data<- (rawdata[complete.cases(rawdata),])
###以下绘制缺失数据热图
vis_miss(rawdata,
show_perc = TRUE,
show_perc_col = TRUE,
cluster = TRUE)
###以下绘制缺失数据upset图，绘制前10个最多缺失的列
gg_miss_upset(rawdata,nsets = 15)
na.per<- (dim(rawdata)[1]/1000)###定义每列删除缺失的阈值
###定义删除缺失值函数为naf
naf<-function(x){
nas<-sum(is.na(x))
return(nas)
}
###以下按照缺失值阈值进行筛选
na_names<- apply(rawdata,2, naf)%>%
as.data.frame
newdata<- rawdata[,(na_names[,1]<= na.per)]
colnames(rawdata[,(na_names[,1]>na.per)])
save(newdata,file = "newdata.RData")
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下进行亚组分析
data_final%>%filter(.,TBIL>=250)->data_final
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:17];allvar
allvar <- allvar[1:16];allvar
#以下进行结果变量定义
dependent <-"Complication.Criteria"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
write.csv(t2,"Univariate_analysis.csv")
str(data_final)
#以下进行结果变量定义
dependent <-"Pancreatic.leakage "
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
#以下进行结果变量定义
dependent <-"Pancreatic.leakage"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
write.csv(t2,"Univariate_analysis.csv")
##载入需要的R包
library(compareGroups)
library(rms)
library(ggpubr)
library(finalfit)
library(gtsummary)
library(tidyverse)
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下进行亚组分析
data_final%>%filter(.,TBIL<250)->data_final
#以下将所有列名纳入一个向量并选择自变量
names(data_final)%>%dput()->allvar;allvar
allvar <- allvar[1:16];allvar
#以下进行结果变量定义
dependent <-"Pancreatic.leakage"
#以下进行单因素分析
explanatory <- allvar
data_final  %>%
finalfit(dependent,explanatory,
metrics=T,  #metrics=T表示输出模型检验的指标
add_dependent_label=F) -> t2  #add_dependent_label=F表示不在表的左上角添加因变量标签。
write.csv(t2,"Univariate_analysis.csv")
install.packages("quallnt")
install.packages("QualInt")
library(QualInt)
#清空环境变量
rm(list = ls())
options(stringsAsFactors = T)
#以下读入文件并进行预览
setwd("D:/pipeline")
load("newdata.RData")
data_final <-newdata
str(data_final)
#以下分析亚组的交互作用
attach(data_final)
data_final <- mutate(data_final,grup = case_when(
TBIL >= 250 ~ "resection",
TBIL < 250 ~"ablation"  ))
str(data_final)
data_final <- mutate(data_final,grup = case_when(
TBIL >= 250 ~ "high",
TBIL < 250 ~"low"  ))
str(data_final)
test1 <- qualint(Pancreatic.leakage, PBD, grup);test1
#以下分析亚组的交互作用
attach(data_final)
test1 <- qualint(Pancreatic.leakage, PBD, grup);test1
library(survivalmodels)
library(survivalsvm)
library(survival)
library(survminer)
library(ggpubr)
library(tidyverse)
library(survivalROC)
library(reticulate)
install.packages("pec")
library(survivalmodels)
library(compareGroups)
library(rms)
library(survival)
library(survminer)
library(ggpubr)
library(tidyverse)
library(gtsummary)
library(pec)
#构建模拟数据集
train <- simsurvdata(100)
str(data_final)
#构建模拟数据集
data_final <- simsurvdata(100)
str(data_final)
#构建模拟数据集
data_final <- simsurvdata(1000)
rm(list = ls())
options(stringsAsFactors = T)
#构建模拟数据集
data_final <- simsurvdata(1000)
str(data_final)
library(tidymodels)
library(tidymodels)
set.seed(2022)
dia_split<-initial_split(data_final,prop=.75)
dim(dia_split)
split<-initial_split(data_final,prop=.75)
data_train<-training(split)
data_test<-testing(split)
View(data_test)
str(data_t)
str(data_train)
#构建COX回归模型
cox1 <- cph(Surv(time,status)~sexF+trt+age,
data_train, surv=TRUE)
cox1
summary(cox1)
y
summary(cox1)
summarise(cox1)
cox1
cox1$score
cox1$linear.predictors
cox1$surv.summary
View(data_train)
survprob <- predictSurvProb(cox1,
newdata=data_test,
times=t)
t <- c(12,36,60)
survprob <- predictSurvProb(cox1,
newdata=data_test,
times=t)
head(survprob)
str(data_final)
ggdensity(data_train,time)
ggdensity(data_train,"time")
t <- c(1,3,6)
survprob <- predictSurvProb(cox1,
newdata=data_test,
times=t)
head(survprob)
t <- c(2,3,6)
survprob <- predictSurvProb(cox1,
newdata=data_test,
times=t)
head(survprob)
View(survprob)
#构建模拟数据集
data("colon")
data_final <- colon
str(data_final)
split<-initial_split(data_final,prop=.75)
data_train<-training(split)
data_test<-testing(split)
str(data_train)
#构建COX回归模型
cox1 <- cph(Surv(time,status)~sex+trt+perfor,
data_train, surv=TRUE)
#构建COX回归模型
cox1 <- cph(Surv(time,status)~sex+differ+perfor,
data_train, surv=TRUE)
cox1
View(colon)
365*2
365*3
365*5
t <- c(365,1095,1825)
survprob <- predictSurvProb(cox1,
newdata=data_test,
times=t)
head(survprob)
#计算cox回归
c_index  <- cindex(list("Cox1"=cox1),
Surv(time,status)~sex+differ+perfor,
data=data_test,
eval.times=seq(1,5,0.1))
#计算cox回归
c_index  <- cindex(list("Cox1"=cox1),
Surv(time,status)~sex+differ+perfor,
data=data_test,
eval.times=seq(365,1825,30))
colon <- na.omit(colon)
data_final <- colon
str(data_final)
set.seed(2022)
split<-initial_split(data_final,prop=.75)
data_train<-training(split)
data_test<-testing(split)
str(data_train)
#构建COX回归模型
cox1 <- cph(Surv(time,status)~sex+differ+perfor,
data_train, surv=TRUE)
#计算验证组不同时间点生存概率
t <- c(365,1095,1825)
survprob <- predictSurvProb(cox1,
newdata=data_test,
times=t)
head(survprob)
#计算cox回归
c_index  <- cindex(list("Cox1"=cox1),
Surv(time,status)~sex+differ+perfor,
data=data_test,
eval.times=seq(365,1825,30))
plot(c_index,xlim = c(0,5))
c_index
#计算cox回归
c_index  <- cindex(list("Cox1"=cox1),
Surv(time,status)~sex+differ+perfor,
data=data_test,
eval.times=seq(365,1825,30))
plot(c_index,xlim = c(0,1825))
#计算cox回归
c_index  <- cindex(list("Cox1"=cox1),
Surv(time,status)~sex+differ+perfor,
data=data_test,
eval.times=seq(30,1825,30))
plot(c_index,xlim = c(0,1825))
#计算cox回归C指数并绘图
c_index  <- cindex(list("Cox1"=cox1),
Surv(time,status)~sex+differ+perfor,
data=data_test,
eval.times=seq(30,1825,30),
splitMethod="bootcv",
B=1000)
plot(c_index,xlim = c(0,1825))
#以下绘制校准曲线
calPlot(list("cox1"=cox1),
time=1095,#设置想要观察的时间点
data=data_test,
splitMethod = "BootCv",
B=1000)
#以下绘制校准曲线
calPlot(list("cox1"=cox1),
time=1095,#设置想要观察的时间点
data=data_train,
splitMethod = "BootCv",
B=1000)
library(ggDCA)
